\documentclass{article}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,calc,ifthen,capt-of}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\assign}{:=}
\newcommand{\cdummy}{\cdot}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextbf}[1]{{\bfseries{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newcommand{\tmtextsc}[1]{{\scshape{#1}}}
\newcommand{\tmtextsf}[1]{{\sffamily{#1}}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\newcommand{\tmverbatim}[1]{{\ttfamily{#1}}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\cdummy}{{\cdot}}
\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}
\providecommand{\tmem}[1]{\tmtextit{#1}}
\providecommand{\tmname}[1]{\tmtextsc{#1}}
\providecommand{\tmop}[1]{\ensuremath{\mathrm{#1}}}
\providecommand{\tmrsub}[1]{\tmrsub{\ensuremath{\mathrm{#1}}}}
\providecommand{\tmsamp}[1]{\tmtextsf{#1}}
\providecommand{\tmstrong}[1]{\tmtextbf{#1}}
\providecommand{\tmtextbf}[1]{\tmtextbf{#1}}
\providecommand{\tmtextit}[1]{\tmtextit{#1}}
\providecommand{\tmverbatim}[1]{\tmtexttt{#1}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}

\begin{document}

\title{
  Polkadot Runtime Environment\\
  {\Large Protocol Specification}
}

\date{January 14, 2018}

\maketitle

\section{Conventions and Definitions}

\begin{definition}
  {\tmstrong{Runtime}} is the state transition function of the decentralized
  ledger protocol.
\end{definition}

\begin{definition}
  \label{def-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes, formally referred to as {\tmstrong{$P_n$}}, is a tree with two
  nodes of vertex degree 1 and the other n-2 nodes of vertex degree 2.
  Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots, v_n)$
  where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is the
  edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{def-radix-tree}{\tmstrong{radix r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define $\mathbb{B}_n$ to be the {\tmstrong{set of all byte arrays of
  length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatination of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\section{Block}

In Polkadot RE, a block is made of two main parts, namely the \tmtextit{block
header} and the \tmtextit{list of extrinsics}. {\tmem{The Extrinsics}}
represent the generalization of the concept of {\tmem{transaction}},
containing any set of data that is external to the system, and which the
underlying chain wishes to validate and keep track of.

\subsection{Block Header}\label{block}

The block header is designed to be minimalistic in order to boost the
efficiency of the light clients. It is defined formally as follows:

\begin{definition}
  \label{def-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} is the 32-byte Blake2s hash of
    the header of the parent of the block indicated henceforth by
    \tmtextbf{$H_p$}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}} is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis block has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}} is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the root of the Merkle
    trie, whose leaves represent individual extrinsics being validated in this
    block. This element is formally referred to as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage. Polkadot RE
    does not impose any limitation or specification for this field.
    Essentially, it can be a byte array of any length. This field is indicated
    as {\tmstrong{$H_d$}}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def-block-header-hash}The {\tmstrong{Block Header Hash of Block
  $B$}}, {\tmstrong{$H_h (b)$}}, is the hash of the header of block $B$
  encoded by simple codec:
  \[ H_b (b) \assign \tmop{Blake} 2 s (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsection{Justified Block Header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot RE, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ {\todo{link this to its
  definition from consensus}}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and is formally
  referred to as $A (B)$. An authority Id is 32bit.
\end{itemize}

\subsection{Extrinsics}

Each block also contains a list of extrinsics. Polkadot RE does not specify or
limit the internal of each extrinsics beside the fact that each extrinsics is
a blob of encoded data. The {\tmsamp{extrinsics\_root}} should correspond to
the root of the Merkle trie, whose leaves are made of the block extrinsics
list.

\section{Runtime}\label{sect-entries-into-runtime}

Polkadot RE expects to receive the code for the runtime of the chain as a
compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b = 3 a, 63, 6 f, 64, 65 \]
which is the byte array of ASCII representation of string ``:code'' (see
Section \ref{sect-predef-storage-keys}). For any call to the runtime, Polkadot
RE makes sure that it has most updated runtime as calls to runtime have the
ability to change the runtime code.

The initial runtime code of the chain is embedded as an extrinsics into the
chain initialization JSON file and is submitted to Polkadot RE (see Section
\ref{sect-genisis-block}).

Subsequent calls to the runtime have the ability to call the storage API (see
Section \ref{sect-runtime-api}) to insert a new Wasm blob into runtime storage
slot to upgrade the runtime.

\subsection{Entries into Runtime}

Polkadot RE assumes that at least the following functions are implemented in
the Runtime Wasm blob and has been exported as shown in Snippet
\ref{snippet-runtime-enteries} :

\

{\tmfloat{h}{small}{table}{\begin{tabular}{l}
  \tmverbatim{(export "version" (func \$version))}\\
  \tmverbatim{(export "authorities" (func \$authorities))}\\
  \tmverbatim{(export "execute\_block" (func \$execute\_block)) }
\end{tabular}}{\label{snippet-runtime-enteries}Snippet to export entries into
tho Wasm runtime module}}

\

The following sections describe the standard based on which Polkadot RE
communicates with each runtime entry.

\subsubsection{version}

This entry receives no argument, it returns the vesion data encoded in ABI
format described in Section \ref{sect-abi-encoding} containing the following
data:

\

{\tmfloat{h}{small}{table}{\begin{tabular}{lll}
  \hline
  Name & Type & Description\\
  \hline
  \tmverbatim{spec\_name} & String & runtime identifier\\
  \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
  C++)\\
  \tmverbatim{authoring\_version} & 32-bit non-negative integer & the version
  of the authorship interface\\
  \tmverbatim{spec\_version} & 32-bit non-negative integer & the version of
  the runtime specification\\
  \tmverbatim{impl\_version} & 32-bit non-negative integer & the version of
  the runtime implementation\\
  \tmverbatim{apis} & ApisVec & List of supported API\\
  \hline
\end{tabular}}{Detail of the version data type returns from runtime
\tmverbatim{version} function}}

\subsubsection{authorities}

This entry is to report the set of authorities at a given block. It receives
\tmverbatim{block\_id} as an argument, it returns an array of
\tmverbatim{authority\_id}'s.

\subsubsection{execute\_block}

This entry is responsible to execute all extrinsics in the block and reporting
back the changes into the state storage. It receives the block header and the
block body as its arguments and it returns a triplet:

\

{\tmfloat{h}{small}{table}{\begin{tabular}{lll}
  \hline
  Name & Type & Description\\
  \hline
  \tmverbatim{results} & Boolean & Indicating if the execution was su\\
  \tmverbatim{storage\_changes} & {\todo{???}} & Contains all changes to the
  state storage\\
  \tmverbatim{change\_updat} & {\todo{???}} & \\
  \hline
\end{tabular}}{Detail of the data execute\_block returns after execution}}

\

\subsection{Code Executor}

Polkadot RE provide a Wasm Virtual Machine (VM) to run the runtime. The Wasm
VM exposes the Polkadot RE API to the Runtime. And execute the Runtime as a
Wasm module.

\subsection{ABI Encoding between Runtime and the Runtime
Enviornment}\label{sect-abi-encoding}

All data exchanged between Polkadot RE and the runtime is encoded using SCALE
codec described in Section \ref{sect-scale-codec}.

\section{Network API}

\subsection{Block Submission and Validation}

Block validation is the process, by which the client asserts that a block is
fit to be added to the blockchain. This means that the block is consistent
with the world state and transitions from the state of the system to a new
valid state.

\

Blocks can be handed to the Polkadot RE both from the network stack and from
consensus engine.

\

Both the runtime and the Polkadot RE need to work together to assure block
validity. This can be accomplished by Polkadot RE invoking
\tmverbatim{execute\_block} entry into the runtime as a part of the validation
process.

\

Polkadot RE implements the following procedure to assure the validity of the
block:

{\algorithm{{\tmname{Import-and-Validate-Block($B, \tmop{Just} (B)$)}}

1\quad{\tmname{Verify-Block-Justification}}$(B, \tmop{Just} (B))$

2\quad Verify $H_{p (B)} \in \tmop{Blockchain}$.

3\quad State-Changes = Runtime.{\tmname{$(B)$}}

4\quad{\tmname{Update-World-State}}(State-Changes)}}

\section{State Storage and the Storage Trie}

For storing the state of the system, Polkadot RE implements a hash table
storage where the keys are used to access each data entry state. There is no
limitation neither on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays.

To authenticate the state of the system, the stored data needs to be
re-arranged and hashed in a {\tmem{radix 16 tree}} also known as
{\tmem{base-16 modified Merkle Patricia Tree}}, which hereafter we will refer
to as the {\tmem{{\tmstrong{Trie}},}} in order to compute the hash of the
whole state storage consistently and efficiently at any given time.

As well, modification has been made in the storing of the the nodes' hash in
the Merkle Tree structure to save space on entries storing small entries.

Because the Tri is used to compute the {\tmem{state root}}, $H_r$, (see
Definition \ref{def-block-header}), which is used to authenticate the validity
of the state database, Polkadot RE follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, $H_r$, matches across clients.

\subsection{The General Tree Structure}

As the trie is a radix 16 tree, in this sense, each key value identifies a
unique node in the tree. However, a node in a tree might or might not be
associated with a key in the storage.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a uniform way:

\begin{definition}
  The for the purpose labeling the branches of the Trie key $k$ is encoded to
  $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}_4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}_4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the little endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_1 \tmop{mod} 16, b_2 / 16) \]
  , where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{The Merkle proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications efficiently, the Merkle hash of the storage trie needs to be
computed rigorously.

The Merkle hash of the trie is computed recursively. As such, hash value of
each node depends on the hash value of all its children and also on its value.
Therefore, it suffices to define how to compute the hash value of a typical
node as a function of the hash value of its children and its own value.

\begin{definition}
  Suppose node N of storage state trie has key value $k_N$, and parent key
  value of $k_{P (N)}$, such that:
  \[ \tmop{KeyEncode} (k_N) = (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i -
     1}}, k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{2 n}}) \]
  and
  \[ \tmop{KeyEncode} (k_{P (N)}) = (k_{\tmop{enc}_1}, \ldots,
     k_{\tmop{enc}_{i - 1}}) \]
  We define
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{2 n}}) \]
  to be the {\tmstrong{the partial key}} of N.
\end{definition}

\begin{definition}
  \label{def-node-prefix}For a trie node N, {\tmstrong{Node Prefix }}function
  is a value specifying the node type as follows:
  \[ \tmop{NodePrefix} (N) \assign \left\{ \begin{array}{lll}
       1 &  & N \text{is a leaf node}\\
       254 &  & N \text{is a branch node without value}\\
       255 &  & N \text{is a branch node with value}
     \end{array} \right. \]
\end{definition}

\begin{definition}
  For a given node $N$, with partial key of $\tmop{pk}_N$ and Value $v$, the
  {\tmstrong{encoded representation}} of $N$, formally referred to as
  $\tmop{Enc}_{\tmop{Node}} (N)$ is determined as follows, in case which:
  \begin{itemize}
    \item $N$ is a leaf node:
    \[ \tmop{Enc}_{\tmop{Node}} (N) \assign \tmop{Enc}_{\tmop{len}} (N) ||
       \tmop{HPE} (\tmop{pk}_N) || \tmop{Enc}_{\tmop{SC}} (v) \]
    \item N is a branch node:
    \[ \begin{array}{l}
         \text{Enc\tmrsub{Node}(N)} \assign\\
         \nobracket \tmop{NodePrefix} (N) || \tmop{ChildrenBitmap} (N) \|
         \tmop{HPE}_{\tmop{PC}} (v) || \tmop{Enc}_{\tmop{SC}}
         (\tmop{Enc}_{\tmop{Node}}) ||\\
         \tmop{Enc}_{\tmop{SC}} (N_{C_1}) \ldots \tmop{Enc}_{\tmop{SC}}
         (N_{C_n})
       \end{array} \]
  \end{itemize}
\end{definition}

Where $N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of
$N$.

\begin{definition}
  For a given node $N$, the {\tmstrong{Merkle value}} of $N$, denoted by $H
  (N)$ is defined as follows:
  \[ \begin{array}{lll}
       & H : \mathbb{B} \rightarrow \bigcup_{i = 0^{\nosymbol}}^{32}
       \mathbb{B}_i & \\
       & H (N) : \left\{ \begin{array}{lll}
         \tmop{Enc}_{\tmop{Node}} (N) & \| \tmop{Enc}_{\tmop{Node}} (N)\|< 32
         & \\
         \tmop{Hash} (\tmop{Enc}_{\tmop{Node}} (N)) & \|
         \tmop{Enc}_{\tmop{Node}} (N)\| \geqslant 32 & 
       \end{array} \right. & 
     \end{array} \]
\end{definition}

\section{Extrinsics trie}

To validate that Extrinsics data are stored in a block across clients,
Polkadot RE uses the same trie structure as for the state storage described in
Section \ref{sect-merkl-proof} to generate the Merkle proof.

\section{Consensus Engine}

Consensus in Polkadot RE is acheived during execution of two different
procedures. The first procedure is block production and the second is
finality. Polkadot RE must run these procedures, if and only if it is running
on a validator node.

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple sub chain in various block position. We refer to
this structure as {\tmem{block tree:}}

\begin{definition}
  The {\tmstrong{Block Tree}} of a blockchain is the union of all different
  versions of the blockchain observered by all the node in the system such as
  every such block is a node in the graph and $B_1$ is connected to $B_2$ if
  $B_1$ is parent of $B_2$.
\end{definition}

Because every block in block chain contains a reference to its parent, is easy
to see that the block tree is actually a tree.

A block tree naturally imposes a partial order relationships on the blocks as
follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendent of $B'$ in the block tree.
\end{definition}

\subsection{Block Production}

\subsection{Finality}

Polkadot RE uses GRANDPA Finality protocol {\cite{AlSt19-Grandpa}} to finalize
blocks. Finality is obtained by consequtive rounds of voting by validator
nodes. Validators executes GRANDPA finality process in parallel to Block
Production as an indepenedent service. In this section we describe the
different functions that GRANDPA service is supposed to perform in order to
successfully participates in block finalization process.

\subsubsection{Priliminaries}

\begin{definition}
  \label{def-vote}A {\tmstrong{GRANDPA Vote }}or simply a vote
\end{definition}

\

\subsubsection{Initiating the GRANDPA state}

A validator needs to initiate it states and sync it with other validators, in
order to be able to participate coherently in voting process. In particular,
considering that voting is happening in different rounds and each round of
voting is assigned a unique sequential round number $r_v$, it needs to
determines and set its round counter $r$ in accordence of the current voting
round $r_n$ which is currently undergoing in the network.

\begin{definition}
  A {\tmstrong{Grandpa Voter}}, $v$, is represented by a key pair
  $(k^{\tmop{pr}}_v, k_v)$ where $k_v^{\tmop{pr}}$ represents its private key,
  is a node running Grandpa protocol and broadcast votes to finilse blocks in
  a Polkadot RE based chain. The {\tmstrong{set of all Grandpa voters}} is
  indicated by $V$.
\end{definition}

\begin{definition}
  {\tmstrong{Grandpa state}}, $\tmop{GS}$, is defined as
  \[ \tmop{GS} \assign \{V, r\} \]
  where:
  
  $\tmmathbf{V}$: is the set of voters.
  
  {\tmstrong{r}}: is voting round number.
\end{definition}

Now we need to define what we count as a vote for a block $B$. First a vote is
defined as:

\begin{definition}
  A GRANDPA {\tmstrong{vote}} for block $B$ is a following pair defined as
  \[ (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are block hash and block numbered defined in
  Definitions \ref{def-block-header} and \ref{def-block-header-hash}
  respectively.
\end{definition}

\begin{definition}
  {\tmstrong{Total direct vote for Block $B$ in round $r$}}, formally denoted
  by $v^r_d (B)$ is equal to number votes $v$ casted in round $r$ with $v =
  (H_h (B), H_i (B))$.
\end{definition}

\begin{definition}
  {\tmstrong{Total vote for Block $B$ in round $r$}} is equal to sum of all
  direct votes casted for block $B$ and all $B$'s anscestors formally defined
  as:
  \[ V^r (B) \assign \sum_{B' \leqslant B} V^r_d (B') \]
\end{definition}

\begin{definition}
  Voters engage in maximum two sub-rounds of voting for each round $r$. The
  first sub-round is called {\tmstrong{pre-vote}} and the second sub-round is
  called {\tmstrong{pre-commit}}. Accordingly the total number of votes for
  block during pre-vote and pre-commit sub-rounds are denoted by
  {\tmstrong{$V^{r, \tmop{pv}} (B)$}} by {\tmstrong{$V^{r, \tmop{pc}} (B)$}}.
  \  \ 
\end{definition}

The GRANDPA protocol dictates how an honset voter should vote in each
sub-round which is described in \ref{alg-grandpa-round}

\begin{definition}
  The {\tmstrong{pre-voted}} block $P$ is the block with $V^{r, \tmop{pv}} (P)
  = \tmop{Max} (V^{r, \tmop{pv}} (B) : \tmop{for} \tmop{all} B)$. Similarly
  the {\tmstrong{precommited block }}$C$ is the block with $V^{r, \tmop{pc}}
  (C) = \tmop{Max} (V^{r, \tmop{pc}} (B) : \tmop{for} \tmop{all} B)$.
\end{definition}

\begin{definition}
  Let $B_{v, r}$ be the block voted by the voter $v$ in pre-vote sub-round of
  round $r$,We say round $\tmmathbf{r}$ is {\tmstrong{complete-able}} if
  either:
  \[ C < B_{r, v} \]
  or
  \[ \{ B' |B' > B_{r, v} \tmop{and} V^{r, \tmop{pc}} (B) < 2 / 3 | V | \} \]
  
\end{definition}

As instructed in Algortihm \ref{alg-join-leave-grandpa}, whenever the
membership of Grandpa voters changes, $r$ is set to 0.

{\algorithm{\label{alg-join-leave-grandpa}{\tmname{Join-Leave-Grandpa-Voters}}
(V)

1\quad$r \leftarrow 0$

2\quad{\tmname{Execute-One-Grandpa-Round}}$(r)$}}

\

\

\section{Auxilary Encodings}

\subsection{SCALE Codec}\label{sect-scale-codec}

Polkadot RE uses {\tmem{Simple Concatenated Aggregate Little-Endian'' (SCALE)
codec}} to encode byte arrays to provide canonical encoding and to produce
consistent hash values across their implementation, including the Merkle hash
proof for the State Storage.

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{Byte array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as follows:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \left\{ \begin{array}{lll}
       l^{\nosymbol}_1 b_1 b_2 \ldots b_n &  & 0 \leqslant n < 2^6\\
       i^{\nosymbol}_1 i^{\nosymbol}_2 b_1 \ldots b_n &  & 2^6 \leqslant n <
       2^{14}\\
       j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 b_1 \ldots b_n &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol} b_1 \ldots b_n &
       & 2^{14} \leqslant n
     \end{array} \right. \]
  in which:{\hspace{0.17em}}
  \[ \begin{array}{|l|}
       \hline
       l^1_1 l_1^0 = 00\\
       \hline
       i^1_1 i_1^0 = 01\\
       \hline
       j^1_1 j_1^0 = 10\\
       \hline
       k^1_1 k_1^0 = 11\\
       \hline
     \end{array} \]
  and n is stored in $\tmop{Enc}_{\tmop{SC}} (A)$ in little-endian format in
  base-2 as follows:
  \[ n = \left\{ \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 \ldots i^2_1^{\nosymbol} &  & 2^6 \leqslant n
       < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdummy 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right. \]
  where:
  \[ m = l^7_1 \ldots l^3_1 l^2_1 + 4 \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}} $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of different types is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) |
     \tmop{Enc}_{\tmop{SC}} (A_2) | \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
\end{definition}

\subsection{Hex Encoding}

Practically it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, radix-16 tree keys are
broken in 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{def-hpe}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a sequence
  of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (0, k_1 + 16 k_2, \ldots, k_{2 i - 1} + 16 k_{2 i}) & n = 2 i\\
          (k_1, k_2 + 16 k_3, \ldots, k_{2 i} + 16 k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\subsection{Partial Key Encoding}

\begin{definition}
  \label{def-key-len-enc}Let $N$ be a node in the storage state trie with
  Partial Key $\tmop{PK}_N$. We define the {\tmstrong{Partial key length
  encoding}} function, formally referred to as $\tmop{Enc}_{\tmop{len}} (N)$
  as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{len}} (N) & \assign\\
       \tmop{NodePrefix} (N) & +\\
       \left\{ \begin{array}{lllll}
         (\| \tmop{PK}_N \|) &  & \tmop{NisleafNode} & \& & \| \tmop{PK}_N \|<
         127\\
         (127) || (\tmop{LE} (\| \tmop{PK}_N \|- 127)) &  &
         \tmop{NisaleafNode} & \& & \| \tmop{PK}_N \| \geqslant 127
       \end{array} \right. & 
     \end{array} \]
  where $\tmop{NodePrefix}$ function is defined in Definition
  \ref{def-node-prefix}.
\end{definition}

\section{Genisis Block Specification}\label{sect-genisis-block}

\section{Predefined Storage keys}\label{sect-predef-storage-keys}

\section{Runtime upgrade}\label{sect-runtime-upgrade}

\section{Runtime API}\label{sect-runtime-api}

Runtime API is a set of functions, which Polkadot RE exposes to Runtime in
order to access Storage content and other external functions. Some of the
functions are exposed to the runtime for efficiency reasons. Here is the list
of the functions which Polkadot RE exposes to the runtime:
\begin{itemizedot}
  \item \tmverbatim{ext\_blake2\_256}
  
  \item \tmverbatim{ext\_blake2\_256\_enumerated\_trie\_root}
  
  \item \tmverbatim{ext\_chain\_id}
  
  \item \tmverbatim{ext\_child\_storage\_root}
  
  \item \tmverbatim{ext\_clear\_child\_storage}
  
  \item \tmverbatim{ext\_clear\_prefix}
  
  \item \tmverbatim{ext\_clear\_storage}
  
  \item \tmverbatim{ext\_ed25519\_verify}
  
  \item \tmverbatim{ext\_exists\_child\_storage}
  
  \item \tmverbatim{ext\_free}
  
  \item \tmverbatim{ext\_get\_allocated\_child\_storage}
  
  \item \tmverbatim{ext\_get\_allocated\_storage}
  
  \item \tmverbatim{ext\_get\_child\_storage\_into}
  
  \item \tmverbatim{ext\_get\_storage\_into}
  
  \item \tmverbatim{ext\_kill\_child\_storage}
  
  \item \tmverbatim{ext\_malloc}
  
  \item \tmverbatim{ext\_print\_hex}
  
  \item \tmverbatim{ext\_print\_num}
  
  \item \tmverbatim{ext\_print\_utf8}
  
  \item \tmverbatim{ext\_sandbox\_instance\_teardown}
  
  \item \tmverbatim{ext\_sandbox\_instantiate}
  
  \item \tmverbatim{ext\_sandbox\_invoke}
  
  \item \tmverbatim{ext\_sandbox\_memory\_get}
  
  \item \tmverbatim{ext\_sandbox\_memory\_new}
  
  \item \tmverbatim{ext\_sandbox\_memory\_set}
  
  \item \tmverbatim{ext\_sandbox\_memory\_teardown}
  
  \item \tmverbatim{ext\_set\_child\_storage}
  
  \item \tmverbatim{ext\_set\_storage}
  
  \item \tmverbatim{ext\_storage\_changes\_root}
  
  \item \tmverbatim{ext\_storage\_root}
  
  \item \tmverbatim{ext\_twox\_128}
  
  \item \tmverbatim{ext\_twox\_256}
  
  \item \tmverbatim{ext\_exists\_storage}
\end{itemizedot}

\end{document}
