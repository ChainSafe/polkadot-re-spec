\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,calc,ifthen,alltt,capt-of}
\geometry{letterpaper, paperheight= auto, paperwidth= auto}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\assign}{:=}
\newcommand{\cdummy}{\cdot}
\newcommand{\nin}{\not\in}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextbf}[1]{{\bfseries{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newcommand{\tmtextsc}[1]{{\scshape{#1}}}
\newcommand{\tmtextsf}[1]{{\sffamily{#1}}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\newcommand{\tmverbatim}[1]{{\ttfamily{#1}}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\cdummy}{{\cdot}}
\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}
\providecommand{\tmem}[1]{\tmtextit{#1}}
\providecommand{\tmname}[1]{\tmtextsc{#1}}
\providecommand{\tmop}[1]{\ensuremath{\mathrm{#1}}}
\providecommand{\tmrsub}[1]{\tmrsub{\ensuremath{\mathrm{#1}}}}
\providecommand{\tmsamp}[1]{\tmtextsf{#1}}
\providecommand{\tmstrong}[1]{\tmtextbf{#1}}
\providecommand{\tmtextbf}[1]{\tmtextbf{#1}}
\providecommand{\tmtextit}[1]{\tmtextit{#1}}
\providecommand{\tmverbatim}[1]{\tmtexttt{#1}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\figuretext}{Snippet}
\newcommand{\figuretext}{Figure}

\begin{document}

\title{
  Polkadot Runtime Environment\\
  {\Large Protocol Specification}
}

\date{February 15, 2019}

\maketitle

\section{Conventions and Definitions}

\begin{definition}
  {\tmstrong{Runtime}} is the state transition function of the decentralized
  ledger protocol.\tmverbatim{}
\end{definition}

\begin{definition}
  \label{def-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes formally referred to as {\tmstrong{$P_n$}}, is a tree with two
  nodes of vertex degree 1 and the other n-2 nodes of vertex degree 2.
  Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots, v_n)$
  where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is the
  edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{def-radix-tree}{\tmstrong{radix r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define $\mathbb{B}_n$ to be the {\tmstrong{set of all byte arrays of
  length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatenation of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\begin{definition}
  By \tmverbatim{}the {\tmstrong{little-endian}} representation of a
  non-negative integer, I represented as
  \[ I = (B_n \ldots B_0)_{256} \]
  In two base 256, is a byte array $B = (b_0, b_1, \ldots, b_n)$ such that
  \[ b_i \assign B_i \]
\end{definition}

\begin{definition}
  By {\tmname{{\tmstrong{\tmverbatim{UINT32}}}}} we refer to a non-negative
  integer stored in a byte array of length 4 using little-endian encoding
  format.
\end{definition}

\begin{definition}
  A {\tmstrong{blockchain}} $C$ is a directed path graph. Each node of the
  graph is called {\tmstrong{Block}} and indicated by {\tmstrong{$B$}}. The
  unique sink of $C$ is called {\tmstrong{Genesis Block}}, and the source is
  called the {\tmstrong{Head}} of C. For any vertex $(B_1, B_2)$ where $B_1
  \rightarrow B_2$ we say $B_2$ is the {\tmstrong{parent}} of $B_1$ and we
  indicate it by
  \[ B_2 \assign P (B_1) \]
\end{definition}

\section{Block}

In Polkadot RE, a block is made of two main parts, namely the \tmtextit{block
header} and the \tmtextit{list of extrinsics}. {\tmem{The Extrinsics}}
represent the generalization of the concept of {\tmem{transaction}},
containing any set of data that is external to the system, and which the
underlying chain wishes to validate and keep track of.

\subsection{Block Header}\label{block}

The block header is designed to be minimalistic in order to boost the
efficiency of the light clients. It is defined formally as follows:

\begin{definition}
  \label{def-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} is the 32-byte Blake2s hash of
    the header of the parent of the block indicated henceforth by
    \tmtextbf{$H_p$}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}} is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis block has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}} is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the field which is
    reserved for the runtime to validate the integrity of the extrinsics
    composing the block body. For example, it can hold the root hash of the
    Merkle trie which stores an ordered list of the extrinsics being validated
    in this block. This element is formally referred to as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage. Polkadot RE
    does not impose any limitation or specification for this field.
    Essentially, it can be a byte array of any length. This field is indicated
    as {\tmstrong{$H_d$}}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def-block-header-hash}The {\tmstrong{Block Header Hash of Block
  $B$}}, {\tmstrong{$H_h (b)$}}, is the hash of the header of block $B$
  encoded by simple codec:
  \[ H_b (b) \assign \tmop{Blake} 2 s (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsection{Justified Block Header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot RE, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ {\todo{link this to its
  definition from consensus}}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and is formally
  referred to as $A (B)$. An authority Id is 32bit.
\end{itemize}

\subsection{Extrinsics}

Each block contains as well a list of extrinsics. Polkadot RE does not specify
or limit the internal of each extrinsics beside the fact that each extrinsics
is a byte array encoded using SCALE codec [\ref{def-scale-codec}].

The {\tmsamp{extrinsics\_root}} is set by the runtime, and its value is
opaque to Polkadot RE.

The extrinsics in a block are ordered using pairing each extrinsics by a
UINT32 integer sequential number starting at 0 which is encoded using SCALE
codec.

\section{Interactions with the Runtime}\label{sect-entries-into-runtime}

Runtime is the code implementing the logic of the chain. This code is
decoupled from the Polkadot RE to make the Runtime easily upgradable without
the need to upgrade the Polkadot RE itself. In this section, we describe the
details upon which the Polkadot RE is interacting with the Runtime.

\subsection{Loading the Runtime code \ \ }

Polkadot RE expects to receive the code for the runtime of the chain as a
compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b = \text{3A,63,6F,64,65} \]
which is the byte array of ASCII representation of string ``:code'' (see
Section \ref{sect-predef-storage-keys}). For any call to the runtime, Polkadot
RE makes sure that it has the most updated Runtime as calls to runtime have
potentially the ability to change the runtime code.

The initial runtime code of the chain is embedded as an extrinsics into the
chain initialization JSON file and is submitted to Polkadot RE (see Section
\ref{sect-genisis-block}).

Subsequent calls to the runtime have the ability to call the storage API (see
Section \ref{sect-runtime-api}) to insert a new Wasm blob into runtime storage
slot to upgrade the runtime.

\subsection{Code Executor}

Polkadot RE provides a Wasm Virtual Machine (VM) to run the Runtime. The Wasm
VM exposes the Polkadot RE API to the Runtime, which, on its turn, executes a
call to the Runtime entries stored in the Wasm module. This part of the
Runtime environment is referred to as the {\tmem{{\tmstrong{Executor}}.}}

In this section, we specify the general setup for an Executor call into the
Runtime. In Section \ref{sect-runtime-entries} we specify the parameters and
the return values of each Runtime entry separately.

\subsubsection{ABI Encoding between Runtime and the Runtime
Environment}\label{sect-abi-encoding}

All data exchanged between Polkadot RE and the Runtime is encoded using SCALE
codec described in Section \ref{sect-scale-codec}.

\subsubsection{Access to Runtime API}

When Polkadot RE calls a Runtime entry it should make sure Runtime has access
to the all Polkadot Runtime API functions described in Appendix
\ref{sect-runtime-api}. This can be done for example by loading another Wasm
module alongside the runtime which imports these functions from Polkadot RE as
host functions.

\subsubsection{Sending Arguments to Runtime \ }

In each invocation of a Runtime entry, the arguments which are supposed to be
sent to the entry need to be encoded using SCALE codec into a byte array $B$.
The Executor then needs to retrieve the memory buffer of the Runtime Wasm
module and extend it to fit the size of the byte array. Then it needs to copy
the byte array value in the correct offset of the extended buffer. Finally,
when the Wasm method corresponding to the entry is called, two UINT32 integers
are sent to the method as arguments. The first one is the offset of the byte
array $B$ in the extended shared memory buffer, and the second one is the size
of $B$.

\subsubsection{The Return Value from a Runtime Entry}

The value which is returned from the invocation represents two consecutive
UINT32 integers in which the first one indicates the pointer to the offset of
the result returned by the entry encoded in SCALE codec in the memory buffer.
The second one provides the size of the blob.

\subsection{Entries into Runtime}\label{sect-runtime-entries}

Polkadot RE assumes that at least the following functions are implemented in
the Runtime Wasm blob and has been exported as shown in Snippet
\ref{snippet-runtime-enteries}:

\tmfloat{h}{small}{figure}{\begin{tmcode}[cpp]
(export "version" (func $version))
(export "authorities" (func $authorities))
(export "execute_block" (func $execute_block))
(export "validate_transaction" (func $validate_transaction))
(export "initialise_block" (func $initialise_block))
\end{tmcode}}{\label{snippet-runtime-enteries}Snippet to export entries into
tho Wasm runtime module}

The following sections describe the standard based on which Polkadot RE
communicates with each runtime entry.

\subsubsection{version}

This entry receives no argument; it returns the version data encoded in ABI
format described in Section \ref{sect-abi-encoding} containing the following
data:

\

\begin{center}
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{spec\_name} & String & runtime identifier\\
    \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
    C++)\\
    \tmverbatim{authoring\_version} & UINT32 & the version of the authorship
    interface\\
    \tmverbatim{spec\_version} & UINT32 & the version of the runtime
    specification\\
    \tmverbatim{impl\_version} & UINT32 & the version of the runtime
    implementation\\
    \tmverbatim{apis} & ApisVec & List of supported AP\\
    \hline
  \end{tabular}}{Detail of the version data type returns from runtime
  \tmverbatim{version} function}
\end{center}

\subsubsection{authorities}\label{sect-runtime-api-auth}

This entry is to report the set of authorities at a given block. It receives
\tmverbatim{block\_id} as an argument; it returns an array of
\tmverbatim{authority\_id}'s.

\subsubsection{execute\_block}

This entry is responsible for executing all extrinsics in the block and
reporting back the changes into the state storage. It receives the block
header and the block body as its arguments, and it returns a triplet:

\begin{center}
  \
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{results} & Boolean & Indicating if the execution was su\\
    \tmverbatim{storage\_changes} & {\todo{???}} & Contains all changes to the
    state storage\\
    \tmverbatim{change\_updat} & {\todo{???}} & \\
    \hline
  \end{tabular}}{Detail of the data execute\_block returns after execution}
\end{center}

\subsubsection{validate\_transaction}\label{sect-validate-transaction}

{\todo{Explain function}}

\subsection{Runtime API}\label{sect-runtime-api}

Runtime API is a set of functions that Polkadot RE exposes to Runtime to
access external functions needed for various reasons, such as Storage content
access and manipulation, memory allocation and also for efficiency. The
functios are specified in each subsequent subsection for each category of
those functions.

\subsubsection{Storage}

\begin{itemize}
  \item \tmverbatim{ext\_child\_storage\_root}
  
  \item \tmverbatim{ext\_clear\_child\_storage}
  
  \item \tmverbatim{ext\_clear\_prefix}
  
  \item \tmverbatim{ext\_clear\_storage}
  
  \item \tmverbatim{ext\_exists\_child\_storage}
  
  \item \tmverbatim{ext\_get\_allocated\_child\_storage}
  
  \item \tmverbatim{ext\_get\_allocated\_storage}
  
  \item \tmverbatim{ext\_get\_child\_storage\_into}
  
  \item \tmverbatim{ext\_get\_storage\_into}
  
  \item \tmverbatim{ext\_kill\_child\_storage}
  
  \item \tmverbatim{ext\_set\_child\_storage}
  
  \item \tmverbatim{ext\_set\_storage}
  
  Sets the value of a specific key in the state storage.
  
  {\tmstrong{Arguments}}:
  \begin{itemize}
    \item \tmverbatim{key}: 32bit pointer pointing the buffer containing the
    key.
    
    \item \tmverbatim{key\_len}: UINT32 integer specifying the key length.
    
    \item \tmverbatim{value}: 32bit pointer pointing the buffer containing the
    value to be stored under the key.
    
    \item \tmverbatim{value\_len}: UINT32 integer specifying the length of the
    value buffer.
  \end{itemize}
  \item \tmverbatim{ext\_storage\_changes\_root}
  
  \item \tmverbatim{ext\_storage\_root}
  
  \item \tmverbatim{ext\_exists\_storage}
\end{itemize}

\subsubsection{Memory}

\begin{itemize}
  \item \tmverbatim{ext\_malloc}
  
  Allocates memory of size \tmverbatim{size} in the heap and returns a 32bit
  pointer to the allocated memory.
  
  {\tmstrong{Arguments:}}
  \begin{itemize}
    \item \tmverbatim{size:} UINT32 integer indicating the size of the buffer
    to be allocated. 
  \end{itemize}
  \item \tmverbatim{ext\_free}
  
  Deallocates a previously allocated memory.
  
  {\tmstrong{Arguments:}}
  \begin{itemize}
    \item \tmverbatim{addr}: 32bit pointer pointing to the allocated memory.
  \end{itemize}
\end{itemize}

\subsubsection{Input/Output}

\begin{itemize}
  \item \tmverbatim{ext\_print\_hex}
  
  \item \tmverbatim{ext\_print\_num}
  
  \item \tmverbatim{ext\_print\_utf8}
\end{itemize}

\subsubsection{Cryptograhpic auxilary functions}

\begin{itemize}
  \item \tmverbatim{ext\_blake2\_256}
  
  \item \tmverbatim{ext\_blake2\_256\_enumerated\_trie\_root}
  
  \item \tmverbatim{ext\_ed25519\_verify}
  
  \item \tmverbatim{ext\_twox\_128}
  
  \item \tmverbatim{ext\_twox\_256}
  
  \ 
\end{itemize}

\subsubsection{Sandboxing}

\begin{itemize}
  \item \tmverbatim{ext\_sandbox\_instance\_teardown}
  
  \item \tmverbatim{ext\_sandbox\_instantiate}
  
  \item \tmverbatim{ext\_sandbox\_invoke}
  
  \item \tmverbatim{ext\_sandbox\_memory\_get}
  
  \item \tmverbatim{ext\_sandbox\_memory\_new}
  
  \item \tmverbatim{ext\_sandbox\_memory\_set}
  
  \item \tmverbatim{ext\_sandbox\_memory\_teardown}
  
  \ 
\end{itemize}
\subsubsection{Misc}
\begin{itemizedot}
  \item \tmverbatim{ext\_chain\_id}
\end{itemizedot}

\section{Network Interactions}

\subsection{Extrinsics Submission}

Extrinsic submission is made by sending an extrinsic network message. The
structure of this message is specified in Definition
\ref{def-extrinsic-network-message}.

Upon receiving an extrinsics message, Polkadot RE decodes the transaction and
calls \tmverbatim{validate\_trasaction} runtime function defined in Section
\ref{sect-validate-transaction}, to check the validity of the extrinsic. If
\tmverbatim{validate\_transaction} considers the submitted extrinsics as a
valid one, Polkadot RE makes the extrinsics available for the consensus engine
for inclusion in future blocks.

\subsection{Network Messages}

\begin{definition}
  \label{def-extrinsic-network-message}{\tmstrong{Extrinsic submission network
  message: }}{\todo{\label{def-extrinsic-network-message}{\tmstrong{Extrinsic
  submission network message definition}}}}
\end{definition}

\subsection{Block Submission and Validation}

Block validation is the process, by which the client asserts that a block is
fit to be added to the blockchain. This means that the block is consistent
with the world state and transitions from the state of the system to a new
valid state.

Blocks can be handed to the Polkadot RE both from the network stack and from
the consensus engine.

Both the Runtime and the Polkadot RE need to work together to assure block
validity. This can be accomplished by Polkadot RE invoking
\tmverbatim{execute\_block} entry into the runtime as a part of the validation
process.

Polkadot RE implements the following procedure to assure the validity of the
block:

{\algorithm{{\tmname{Import-and-Validate-Block($B, \tmop{Just}
(B)$)}}}{{\algorithmic{{\state{{\tmname{Verify-Block-Justification}}$(B,
\tmop{Just} (B))$}}

{\state{{\IF{$B$ {\tmstrong{is}} Finalized {\tmstrong{and}} $P (B)$
{\tmstrong{is not}} Finalized}}}}

{\state{{\tmname{Mark-as-Final}}$(P (B))${\END}}}

{\state{Verify $H_{p (B)} \in \tmop{Blockchain}$}}

{\state{State-Changes = Runtime{\tmname{$(B)$}}}}

{\state{{\tmname{Update-World-State}}(State-Changes)}}}}}}

For the definition of the finality and the finalized block see Section
\ref{sect-finality}.

\section{State Storage and the Storage Trie}

For storing the state of the system, Polkadot RE implements a hash table
storage where the keys are used to access each data entry state. There is no
limitation either on the size of the key nor the size of the data stored under
them, besides the fact that they are byte arrays.

\subsection{Accessing The System Storage }

Polkadot RE implements various functions to facilitate access to the system
storage for the runtime. Section \ref{sect-runtime-api} lists all of those
functions. Here we define the essential ones which are also used by the
Polkadot RE.

\begin{definition}
  \label{def-state-read-write}The {\tmstrong{StateRead}} and
  {\tmstrong{StateWrite}} functions provide basic access to the State Storage:
  \[ v = \tmop{StateRead} (k) \]
  \[ \tmop{StateWrite} (k, v) \]
  where v and k are byte arrays.
\end{definition}

To authenticate the state of the system, the stored data needs to be
re-arranged and hashed in a {\tmem{radix 16 tree}} also known as
{\tmem{base-16 modified Merkle Patricia Tree}}, which hereafter we refer to as
the {\tmem{{\tmstrong{Trie}},}} in order to compute the hash of the whole
state storage consistently and efficiently at any given time.

As well, a modification has been made in the storing of the nodes' hash in the
Merkle Tree structure to save space on entries storing small entries.

Because the Trie is used to compute the {\tmem{state root}}, $H_r$, (see
Definition \ref{def-block-header}), which is used to authenticate the validity
of the state database, Polkadot RE follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, $H_r$, matches across clients.

\subsection{The General Tree Structure}

As the trie is a radix 16 tree, in this sense, each key value identifies a
unique node in the tree. However, a node in a tree might or might not be
associated with a key in the storage.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a uniform way:

\begin{definition}
  For the purpose of labeling the branches of the Trie, the key $k$ is encoded
  to $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}_4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}_4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the little endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_i \tmop{mod} 16, b_i / 16) \]
  , where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{The Merkle proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications efficiently, the Merkle hash of the storage trie needs to be
computed rigorously.

The Merkle hash of the trie is computed recursively. As such, the hash value
of each node depends on the hash value of all its children and also on its
value. Therefore, it suffices to define how to compute the hash value of a
typical node as a function of the hash value of its children and its own
value.

\begin{definition}
  Suppose node N of storage state trie has key value $k_N$, and parent key
  value of $k_{P (N)}$, such that:
  \[ \tmop{KeyEncode} (k_N) = (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i -
     1}}, k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{2 n}}) \]
  and
  \[ \tmop{KeyEncode} (k_{P (N)}) = (k_{\tmop{enc}_1}, \ldots,
     k_{\tmop{enc}_{i - 1}}) \]
  We define
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{2 n}}) \]
  to be the {\tmstrong{the partial key}} of N.
\end{definition}

\begin{definition}
  \label{def-node-prefix}For a trie node N, {\tmstrong{Node Prefix }}function
  is a value specifying the node type as follows:
  \[ \tmop{NodePrefix} (N) \assign \left\{ \begin{array}{lll}
       1 &  & N \text{is a leaf node}\\
       254 &  & N \text{is a branch node without value}\\
       255 &  & N \text{is a branch node with value}
     \end{array} \right. \]
\end{definition}

\begin{definition}
  For a given node $N$, with partial key of $\tmop{pk}_N$ and Value $v$, the
  {\tmstrong{encoded representation}} of $N$, formally referred to as
  $\tmop{Enc}_{\tmop{Node}} (N)$ is determined as follows, in case which:
  \begin{itemize}
    \item $N$ is a leaf node:
    \[ \tmop{Enc}_{\tmop{Node}} (N) \assign \tmop{Enc}_{\tmop{len}} (N) ||
       \tmop{HPE} (\tmop{pk}_N) || \tmop{Enc}_{\tmop{SC}} (v) \]
    \item N is a branch node:
    \[ \begin{array}{l}
         \text{Enc\tmrsub{Node}(N)} \assign\\
         \nobracket \tmop{NodePrefix} (N) || \tmop{ChildrenBitmap} (N) \|
         \tmop{HPE}_{\tmop{PC}} (v) || \tmop{Enc}_{\tmop{SC}}
         (\tmop{Enc}_{\tmop{Node}}) ||\\
         \tmop{Enc}_{\tmop{SC}} (N_{C_1}) \ldots \tmop{Enc}_{\tmop{SC}}
         (N_{C_n})
       \end{array} \]
  \end{itemize}
\end{definition}

Where $N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of
$N$.

\begin{definition}
  For a given node $N$, the {\tmstrong{Merkle value}} of $N$, denoted by $H
  (N)$ is defined as follows:
  \[ \begin{array}{lll}
       & H : \mathbb{B} \rightarrow \bigcup_{i = 0^{\nosymbol}}^{32}
       \mathbb{B}_i & \\
       & H (N) : \left\{ \begin{array}{lll}
         \tmop{Enc}_{\tmop{Node}} (N) & \| \tmop{Enc}_{\tmop{Node}} (N)\|< 32
         & \\
         \tmop{Hash} (\tmop{Enc}_{\tmop{Node}} (N)) & \|
         \tmop{Enc}_{\tmop{Node}} (N)\| \geqslant 32 & 
       \end{array} \right. & 
     \end{array} \]
\end{definition}

\section{Consensus Engine}

Consensus in Polkadot RE is achieved during the execution of two different
procedures. The first procedure is block production and the second is
finality. Polkadot RE must run these procedures, if and only if it is running
on a validator node.

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple subchains in various block positions. We refer
to this structure as a {\tmem{block tree:}}

\begin{definition}
  The {\tmstrong{Block Tree}} of a blockchain is the union of all different
  versions of the blockchain observed by all the nodes in the system such as
  every such block is a node in the graph and $B_1$ is connected to $B_2$ if
  $B_1$ is a parent of $B_2$.
\end{definition}

Because every block in the blockchain contains a reference to its parent, it
is easy to see that the block tree is actually a tree.

A block tree naturally imposes partial order relationships on the blocks as
follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendant of $B'$ in the block tree.
\end{definition}

\subsection{Block Production}

\subsection{Finality}\label{sect-finality}

Polkadot RE uses GRANDPA Finality protocol {\cite{AlSt19-Grandpai}} to
finalize blocks. Finality is obtained by consecutive rounds of voting by
validator nodes. Validators execute GRANDPA finality process in parallel to
Block Production as an independent service. In this section, we describe the
different functions that GRANDPA service is supposed to perform to
successfully participate in the block finalization process.

\subsubsection{Preliminaries}

\begin{definition}
  A {\tmstrong{GRANDPA Voter}}, $v$, is represented by a key pair
  $(k^{\tmop{pr}}_v, v_{\tmop{id}})$ where $k_v^{\tmop{pr}}$ represents its
  private key which is an $\tmop{ED} 25519$ private key, is a node running
  GRANDPA protocol, and broadcasts votes to finalize blocks in a Polkadot RE -
  based chain. The {\tmstrong{set of all GRANDPA voters}} is indicated by
  $\mathbb{V}$. For a given block B, we have
  \[ \mathbb{V}_B = \tmverbatim{\tmop{authorities}} (B) \]
  where $\mathtt{authorities}$ is the entry into runtime described in Section
  \ref{sect-runtime-api-auth}.
\end{definition}

\begin{definition}
  {\tmstrong{GRANDPA state}}, $\tmop{GS}$, is defined as
  \[ \tmop{GS} \assign \{\mathbb{V}, \tmop{id}_{\mathbb{V}}, r\} \]
  where:
  
  $\mathbb{V}$: is the set of voters.
  
  {\tmstrong{$\mathbb{V}_{\tmop{id}}$}}: is an incremental counter tracking
  membership, which changes in V.
  
  {\tmstrong{r}}: is the voting round number.
\end{definition}

Now we need to define how Polkadot RE counts the number of votes for block
$B$. First a vote is defined as:

\begin{definition}
  \label{def-vote}A {\tmstrong{GRANDPA vote }}or simply a vote for block $B$
  is an ordered pair defined as
  \[ V_{\nosymbol} (B) \assign (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are the block hash and the block number
  defined in Definitions \ref{def-block-header} and
  \ref{def-block-header-hash} respectively.
\end{definition}

\begin{definition}
  Voters engage in a maximum of two sub-rounds of voting for each round $r$.
  The first sub-round is called {\tmstrong{pre-vote}} and the second sub-round
  is called {\tmstrong{pre-commit}}.
  
  By {\tmstrong{$V_v^{r, \tmop{pv}}$}} and {\tmstrong{$V_v^{r, \tmop{pc}}$}}
  we refer to the vote cast by voter $v$ in round $r$ (for block $B$) during
  the pre-vote and the pre-commit sub-round respectively.
\end{definition}

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm \ref{alg-grandpa-round}. After
defining what constitues a vote in GRANDPA, we define how GRANDPA counts
votes.

\begin{definition}
  Voter $v$ {\tmstrong{equivocates}} if they broadcast two or more valid votes
  to blocks not residing on the same branch of the block tree during one
  voting sub-round. In such a situation, we say that $v$ is an
  {\tmstrong{equivocator}} and any vote $V_v^{r, \tmop{stage}} (B)$ cast by
  $v$ in that round is an {\tmstrong{equivocatory vote}} and
  \[ \mathcal{E}^{r, \tmop{stage}} \]
  represents the set of all equivocators voters in sub-round
  ``$\tmop{stage}$'' of round $r$. When we want to refer to the number of
  equivocators whose equivocation has been observed by voter $v$ we refer to
  it by:
  \[ \mathcal{E}^{r, \tmop{stage}}_{\tmop{obs} (v)} \]
  
\end{definition}

\begin{definition}
  A vote $V_v^{r, \tmop{stage}} = V (B)$ is {\tmstrong{invalid}} if
  \begin{itemize}
    \begin{itemizedot}
      \item $H (B)$ does not correspond to a valid block;
      
      \item $B$ is not an (eventual) descendant of a previously finalized
      block;
      
      \item $M^{r, \tmop{stage}}_v$ does not bear a valid signature;
      
      \item $\tmop{id}_{\mathbb{V}}$ does not match the current $\mathbb{V}$;
      
      \item If $V_v^{r, \tmop{stage}}$ is an equivocatory vote.
    \end{itemizedot}
  \end{itemize}
\end{definition}

\begin{definition}
  For validator v, {\tmstrong{the set of observed direct votes for Block $B$
  in round $r$}}, formally denoted by $\tmop{VD}^{r, \tmop{stage}}_{\tmop{obs}
  (v)}^{\nosymbol}_{\nosymbol} (B)$ is equal to the union of:
  \begin{itemizedot}
    \item set of valid votes $V^{r, \tmop{stage}}_{v_i}$ cast in round $r$ and
    received by v such that $V^{r, \tmop{stage}}_{v_i} = V (B)$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  We refer to {\tmstrong{the set of total votes observed by voter $v$ in
  sub-round ``$\tmop{stage}$'' of round $r$}} by {\tmstrong{$V^{r,
  \tmop{stage}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol}$}}.
  
  The {\tmstrong{set of all observed votes by $v$ in the sub-round stage of
  round $r$ for block $B$}}, {\tmstrong{$V^{r, \tmop{stage}}_{\tmop{obs} (v)}
  (B)$}} is equal to all of the observed direct votes casted for block $B$ and
  all of the $B$'s descendents defined formally as:
  \[ V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) \assign \bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \tmop{VD}^{r, \tmop{stage}}_{\tmop{obs} (v)}
     (B')_{\nosymbol}^{\nosymbol}_{\nosymbol} \]
  The {\tmstrong{total number of observed votes for Block $B$ in round $r$}}
  is defined to be the size of that set plus the total number of equivocators
  voters:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) = |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | \mathcal{E}^{r,
     \tmop{stage}}_{\tmop{obs} (v)} | \]
\end{definition}

\begin{definition}
  The current {\tmstrong{pre-voted}} block $B^{r, \tmop{pv}}_v$ is the block
  with
  \[ H_n (B^{r, \tmop{pv}}_v) = \tmop{Max} (H_n (B) | \forall B :
     \#V_{\tmop{obs} (v)}^{r, \tmop{pv}} (B) \geqslant 2 / 3|\mathbb{V}|) \]
\end{definition}

Note that for genesis block $\tmop{Genesis}$ we always have $\#V_{\tmop{obs}
(v)}^{r, \tmop{pv}} (B) = | \mathbb{V} |$.

\

Finally, we define when a voter $v$ see a round as completable, that is when
they are confident that $B_v^{r, \tmop{pv}}$ is an upper bound for what is
going to be finalised in this round. \

\begin{definition}
  We say that round $r$ is {\tmstrong{completable}} if $|V^{r,
  \tmop{pc}}_{\tmop{obs} (v)} | +\mathcal{E}^{r, \tmop{pc}}_{\tmop{obs} (v)} >
  \frac{2}{3} \mathbb{V}$ and for all $B' > B_v^{r, \tmop{pv}}$:
  \[ \begin{array}{l}
       |V^{r, \tmop{pc}}_{\tmop{obs} (v)} | -\mathcal{E}^{r,
       \tmop{pc}}_{\tmop{obs} (v)} - |V^{r, \tmop{pc}}_{\tmop{obs}
       (v)_{\nosymbol}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array} \]
\end{definition}

Note that in practice we only need to check the inequality for those $B' >
B_v^{r, \tmop{pv}}$ where $|V^{r, \tmop{pc}}_{\tmop{obs} (v)_{\nosymbol}} (B')
| > 0$.

\

\subsubsection{Voting Messages Specification}

Voting is done by means of broadcasting voting messages to the network.
Validators inform their peers about the block finalized in round $r$ by
broadcasting a finalization message (see Algorithm \ref{alg-grandpa-round} for
more details). These messages are specified in this section.

\begin{definition}
  A vote casted by voter $v$ should be broadcasted as a {\tmstrong{message
  $M^{r, \tmop{stage}}_v$}} to the network by voter $v$ with the following
  structure:
  \[ M^{r, \tmop{stage}}_v \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}, \tmop{Enc}_{\tmop{SC}} (\tmop{stage}, V_v^{r,
     \tmop{stage}}, \tmop{Sig}_{\tmop{ED} 25519} (\tmop{Enc}_{\tmop{SC}}
     (\tmop{stage}, V_v^{r, \tmop{stage}}, r, V_{\tmop{id}}), v_{\tmop{id}})
  \]
  Where:
  \begin{center}
    \begin{tabular}{rll}
      r: & round number & 64 bit integer\\
      $V_{\tmop{id}}$: & incremental change tracker counter & 64 bit integer\\
      {\rightaligned{$v_{\tmop{id}}$}}: & Ed25519 public key of $v$ & 4 byte
      array\\
      {\rightaligned{}}$\tmop{stage}$: & 0 if it is the pre-vote sub-round & 1
      byte\\
      & 1 if it the pre-commit sub-round & 
    \end{tabular}
  \end{center}
  
\end{definition}

\begin{definition}
  \label{def-grandpa-justification}The {\tmstrong{justification for block B in
  round $r$}} of GRANDPA protocol defined $J^r (B)$ is a vector of pairs of
  the type:
  \[ (V (B'), (\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B'), v_{\tmop{id}})) \]
  in which either
  \[ B' > B \]
  or $V^{r, \tmop{pc}}_{v_i} (B')$ is an equivocatory vote.
  
  In all cases, $\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B')$ is the signature of
  voter $v_i$ broadcasted during the pre-commit sub-round of round r.
\end{definition}

\begin{definition}
  {\tmstrong{$\tmop{GRANDPA}$ finalizing message for block $B$ in round $r$}}
  represented as {\tmstrong{$M_v^{r, \tmop{Fin}}$(B)}} is a message
  broadcasted by voter $v$ to the network indicating that voter $v$ has
  finalized block $B$ in round $r$. It has the following structure:
  \[ M^{r, \tmop{Fin}}_v (B) \assign \tmop{Enc}_{\tmop{SC}} (r, V (B), J^r
     (B)) \]
  in which $J^r (B)$ in the justification defined in Definition
  \ref{def-grandpa-justification}.
\end{definition}

\subsubsection{Initiating the GRANDPA State}

A validator needs to initiate its state and sync it with other validators, to
be able to participate coherently in the voting process. In particular,
considering that voting is happening in different rounds and each round of
voting is assigned a unique sequential round number $r_v$, it needs to
determine and set its round counter $r$ in accordance with the current voting
round $r_n$, which is currently undergoing in the network.

As instructed in Algorithm \ref{alg-join-leave-grandpa}, whenever the
membership of GRANDPA voters changes, $r$ is set to 0 and $V_{\tmop{id}}$
needs to be incremented.

{\algorithm{\label{alg-join-leave-grandpa}{\tmname{Join-Leave-Grandpa-Voters}}
($\mathcal{V}$)}{{\algorithmic{{\state{$r \leftarrow 0$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \tmop{ReadState} ('
\tmop{AUTHORITY} \_ \tmop{SET} \_ \tmop{KEY}')$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \mathcal{V}_{\tmop{id}} + 1$}}

{\state{{\tmname{Execute-One-Grandpa-Round}}$(r)$}}}}}}

Each voter should run Algorithm \ref{alg-completable-round} to verify that a
round is completable.

\subsubsection{Voting Process in Round $r$}

For each round $r$, an honest voter $v$ must participate in the voting process
by following Algorithm \ref{alg-grandpa-round}.

{\algorithm{\label{alg-grandpa-round}{\tmname{Play-Grandpa-round}}$(r)$}{{\algorithmic{{\state{$t_{r,
v} \leftarrow$Time}}

{\state{$\tmop{primary} \leftarrow${\tmname{Derive-Primary}}}}

{\state{{\IF{$v = \tmop{primary}$}}}}

{\state{{\tmname{Broadcast(}}\left.$M_{v_{\nosymbol}}^{r - 1,
\tmop{Fin}}$({\tmname{Best-Final-Candidate}}($r$-1))\right){\END}}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} Time $\geqslant t_{r_,
v} + 2 \times T$ {\tmstrong{or}} $r$ {\tmstrong{is}} completable){\END}}}

{\state{$L \leftarrow${\tmname{Best-Final-Candidate}}($r$-1)}}

{\state{{\IF{{\tmname{Received($M_{v_{\tmop{primary}}}^{r, \tmop{pv}} (B)$)}}
{\tmstrong{and}} $B^{r, \tmop{pv}}_v \geqslant B > L$}}}}

{\state{$N \leftarrow B${\END}}}

{\state{{\ELSE{\ }}}}

{\state{$N \leftarrow B' : H_n (B') = \max \{H_n (B') : B' > L\} \END$}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{pv}} (N)$)}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} $B^{r,
\tmop{pv}_{\nosymbol}}_v \geqslant L$ {\tmstrong{and}} (Time $\geqslant t_{r_,
v} + 4 \times T${\tmstrong{ or }}$r$ {\tmstrong{is}} completable))}}

{\state{{\tmname{Broadcast($M_v^{r, \tmop{pc}}$($B_v^{r, \tmop{pv}}$))}}}}

{\state{{\tmname{Play-Grandpa-round}}($r + 1$)}}}}}}

{\algorithm{\label{alg-grandpa-best-candidate}{\tmname{Best-Final-Candidate}}($r$)}{{\algorithmic{{\state{$\mathcal{C}_{\nosymbol}
\leftarrow \{B' |B' \leqslant B_v^{r, \tmop{pv}} : |V_v^{r, \tmop{pc}} |
-\#V_v^{r, \tmop{pc}} (B') \leqslant 1 / 3|\mathbb{V}|\}$}}

{\state{{\IF{$\mathcal{C}= \phi$}}}}

{\state{{\RETURN{$\phi${\END}}}}}

{\state{{\ELSE{\ }}}}

{\state{{\RETURN{$E \in \mathcal{C}: H_n (E) = \max \{H_n (B') : B' \in
\mathcal{C}\}${\END}}}}}}}}}

{\algorithm{{\tmname{Attempt-To-Finalize-Round}}($r$)}{{\algorithmic{{\state{$L
\leftarrow${\tmname{Last-Finalized-Block}}}}

{\state{$E \leftarrow${\tmname{Best-Final-Candidate}}($r$)}}

{\state{{\IF{$E \geqslant L$ {\tmstrong{and}} $V^{r - 1,
\tmop{pc}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol} (E) > 2 / 3
|\mathcal{V}|$}}}}

{\state{{\tmname{Last-Finalized-Block}}$\leftarrow B^{r, \tmop{pc}}$}}

{\state{{\IF{$M_v^{r, \tmop{Fin}} (E) \nin${\tmname{Received-Messages}}}}}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{Fin}} (E)$)}}

{\state{{\RETURN{{\END}{\END}}}}}

{\state{{\tmstrong{schedule-call}} {\tmname{Attempt-To-Finalize-Round}}($r$)
{\tmstrong{when}} {\tmname{Receive-Messages}} }}}}}}

\section{Auxiliary Encodings}

\subsection{SCALE Codec}\label{sect-scale-codec}

Polkadot RE uses {\tmem{Simple Concatenated Aggregate Little-Endian'' (SCALE)
codec}} to encode byte arrays that provide canonical encoding and to produce
consistent hash values across their implementation, including the Merkle hash
proof for the State Storage.

\begin{definition}
  \label{def-scale-codec}The {\tmstrong{SCALE codec}} for {\tmstrong{Byte
  array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as follows:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \left\{ \begin{array}{lll}
       l^{\nosymbol}_1 b_1 b_2 \ldots b_n &  & 0 \leqslant n < 2^6\\
       i^{\nosymbol}_1 i^{\nosymbol}_2 b_1 \ldots b_n &  & 2^6 \leqslant n <
       2^{14}\\
       j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 b_1 \ldots b_n &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol} b_1 \ldots b_n &
       & 2^{30} \leqslant n
     \end{array} \right. \]
  in which:{\hspace{0.17em}}
  \[ \begin{array}{|l|}
       \hline
       l^1_1 l_1^0 = 00\\
       \hline
       i^1_1 i_1^0 = 01\\
       \hline
       j^1_1 j_1^0 = 10\\
       \hline
       k^1_1 k_1^0 = 11\\
       \hline
     \end{array} \]
  and n is stored in $\tmop{Enc}_{\tmop{SC}} (A)$ in little-endian format in
  base-2 as follows:
  \[ \left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 \ldots i^2_1^{\nosymbol} &  & 2^6 \leqslant n
       < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdummy 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} \assign n \]
  where:
  \[ k^7_1 \ldots k^3_1 k^2_1 : = m - 4 \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}} $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of different types, is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) |
     \tmop{Enc}_{\tmop{SC}} (A_2) | \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
\end{definition}

\subsection{Hex Encoding}

Practically, it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, radix-16 tree keys are
broken in 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{def-hpe}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a sequence
  of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (0, k_1 + 16 k_2, \ldots, k_{2 i - 1} + 16 k_{2 i}) & n = 2 i\\
          (k_1, k_2 + 16 k_3, \ldots, k_{2 i} + 16 k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\subsection{Partial Key Encoding}

\begin{definition}
  \label{def-key-len-enc}Let $N$ be a node in the storage state trie with
  Partial Key $\tmop{PK}_N$. We define the {\tmstrong{Partial key length
  encoding}} function, formally referred to as $\tmop{Enc}_{\tmop{len}} (N)$
  as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{len}} (N) & \assign\\
       \tmop{NodePrefix} (N) & +\\
       \left\{ \begin{array}{lllll}
         (\| \tmop{PK}_N \|) &  & \tmop{NisleafNode} & \& & \| \tmop{PK}_N \|<
         127\\
         (127) || (\tmop{LE} (\| \tmop{PK}_N \|- 127)) &  &
         \tmop{NisaleafNode} & \& & \| \tmop{PK}_N \| \geqslant 127
       \end{array} \right. & 
     \end{array} \]
  where $\tmop{NodePrefix}$ function is defined in Definition
  \ref{def-node-prefix}.
\end{definition}

\section{Genesis Block Specification}\label{sect-genisis-block}

\section{Predefined Storage keys}\label{sect-predef-storage-keys}

\section{Runtime upgrade}\label{sect-runtime-upgrade}

;

\end{document}
